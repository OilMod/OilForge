
allprojects {
    repositories {
        jcenter()
        mavenCentral()
        mavenLocal()
    }
}

buildscript {
    repositories {
        maven { url = 'https://files.minecraftforge.net/maven' }
        gradlePluginPortal()
    }
    dependencies {
        classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: '3.+', changing: true
        classpath "gradle.plugin.com.lazan:gradle-maven-share:0.4"
    }
}



allprojects {
    apply plugin: 'idea'
    apply plugin: 'eclipse'
    apply plugin: 'maven-publish'
    ext {
        isDepForge = false
        isMaven = false
        delayedSetup = {}
    }
}
subprojects {

    ext {
        title = project.name
        fmlmodtype = "MOD"
    }
    group = 'org.oilmod'
}

//important to now evaluate children as they might change properties we depend on and we do not want to read the default values!
evaluationDependsOnChildren()

allprojects {

    if (project.isDepForge) {
        println "$project.name is forge dep"
        configurations {
            // configuration that holds jars to copy into lib
            compileJars
            providedJars
            releaseJars
            releaseJars.extendsFrom(compileJars)
            compile.extendsFrom(compileJars)
        }
    }
    if (project.isMaven) {
        apply plugin: 'java'
        apply plugin: 'com.lazan.gradlemavenshare'
        fmlmodtype = 'NONE/MAVEN-LIB' //only for debug purposes, is never read
    }


    project.delayedSetup()

    if (project.isDepForge) {
        archivesBaseName = project.projectDir.name
        sourceCompatibility = targetCompatibility = compileJava.sourceCompatibility = compileJava.targetCompatibility = '1.8' // Need this here so eclipse task generates correctly.



        if (project.metaClass.respondsTo(project, "setupForge")) {
            setupForge() //if the subproject wants to do extra forge setup this gets called
        }

        //println "Subproject $project.name properties:  FMLMODTYPE $project.fmlmodtype"
        jar {
            doFirst { task ->
                println "Doing jar task for $task.project.name version ${task.project.version} and FMLMODTYPE $task.project.fmlmodtype"
            }
            manifest {
                attributes([
                        "Specification-Title": project.title,
                        "Specification-Vendor": "oilforge",
                        "Specification-Version": "1", // We are version 1 of ourselves
                        "Implementation-Title": project.name,
                        "Implementation-Version": "${version}",
                        "Implementation-Vendor" :"oilforge",
                        "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
                        "FMLModType": fmlmodtype,
                        //"Class-Path": configurations.releaseJars.collect { "META-INF/libraries/${it.getName()}" }.join(' ') //todo fix dependency inclusion
                ])
            }

            into('META-INF/libraries/') {
                from configurations.releaseJars
            }
        }
    }
}


subprojects {
// Example for how to get properties into the manifest for reading by the runtime..


    task hello {
        doLast { task ->
            println "I'm $task.project.name version ${task.project.version} and FMLMODTYPE $task.project.fmlmodtype"
        }
    }

}
